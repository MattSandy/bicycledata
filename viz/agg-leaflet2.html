<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no"/>
     <script src="http://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js" charset="utf-8"></script>
     <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.css" />
     <script type="text/javascript" src="lib/q.js"></script>

    <style type="text/css">

#map {
  width: 960px;
  height: 500px;
}

svg {
  position: relative;
}

    </style>
  </head>
  <body>
    <div id="map"></div>
    <script type="text/javascript">

    d3.selection.prototype.moveToFront = function() {
      return this.each(function(){
        this.parentNode.appendChild(this);
      });
    };

      // Use Leaflet to implement a D3 geometric transformation.
  function projectPoint(x, y) {
    var point = map.latLngToLayerPoint(new L.LatLng(y, x));
    this.stream.point(point.x, point.y);
  }

var map = L.map('map').setView([44.9763201, -93.2708829], 11);

L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoiZ2VsaWNpYSIsImEiOiJRLUZOV2Z3In0.XYdXJ73QuT8Frxsn1BJ5MA', {
    attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="http://mapbox.com">Mapbox</a>',
    maxZoom: 18,
    id: 'gelicia.mifl322k',
    accessToken: 'pk.eyJ1IjoiZ2VsaWNpYSIsImEiOiJRLUZOV2Z3In0.XYdXJ73QuT8Frxsn1BJ5MA'
}).addTo(map);

var svg = d3.select(map.getPanes().overlayPane).append("svg");

var g = svg.append("g").attr("class", "leaflet-zoom-hide");
var nestData;

var transform = d3.geo.transform({point: projectPoint});

loadData().then(function(){
  var crashes = g.selectAll("circle").data(nestData).enter().append("circle");
  
  map.on("viewreset", function(){
    reset();
  });

  reset();

  function reset() {
    var top = 0;
    var bottom = 0;
    var left = 0;
    var right = 0;

    for (var i = 0; i < nestData.length; i++) {
      if (i==0){
        top = nestData[i].values[0].lat;
        bottom = nestData[i].values[0].lat;
        left = nestData[i].values[0].long;
        right = nestData[i].values[0].long;
      }
      else {
        if (nestData[i].values[0].lat > top){
          top = nestData[i].values[0].lat;
        }
        if (nestData[i].values[0].lat < bottom){
          bottom = nestData[i].values[0].lat;
        }
        if (nestData[i].values[0].long > left){
          left = nestData[i].values[0].long;
        }
        if (nestData[i].values[0].long < right){
          right = nestData[i].values[0].long;
        } 
      }
    }

    var topLeft = map.latLngToLayerPoint(new L.LatLng(top, left)); 
    var bottomRight = map.latLngToLayerPoint(new L.LatLng(bottom, right)); 

      console.log(top, bottom, left, right);
      console.log("topLeft", topLeft);
      console.log("bottomRight", bottomRight);

        svg.attr("width", bottomRight.x - topLeft.x)
        .attr("height", bottomRight.y - topLeft.y)
        .style("left", topLeft.x + "px")
        .style("top", topLeft.y + "px");

      g.attr("transform", "translate(" + -topLeft.x + "," + -topLeft.y + ")");

      crashes.attr({
      fill:"red",
      "stroke-width": 1,
      "stroke": "black",
      opacity: 0.5,
      r: function (d) { return d.intersectTotal;},
       cx: function(d){
        var longLat = [d.values[0].long, d.values[0].lat];
        var point = map.latLngToLayerPoint(new L.LatLng(longLat[1], longLat[0]));
        return point.x;
      },
      cy: function(d){
        var longLat = [d.values[0].long, d.values[0].lat];
        var point = map.latLngToLayerPoint(new L.LatLng(longLat[1], longLat[0]));
        return point.y;
      }
    }).moveToFront();
}

});

function loadData(){
  var def = Q.defer();
  d3.csv("bicycle-data-bad-removed.csv", function(data) {
    nestData = d3.nest().key(function(d){ return d.lat + "," + d.long}).entries(data);

    for (var i = 0; i < nestData.length; i++) {
      var intersectTotal = 0;
      for (var j = 0; j < nestData[i].values.length; j++) {
        if (nestData[i].values[j].Level == "Possible Injury (C)"){
          intersectTotal+=2;
        }
        else if (nestData[i].values[j].Level == "Fatalities"){
          intersectTotal+=5;
        }
        else if (nestData[i].values[j].Level == "Property Damage Only"){
          intersectTotal+=1;
        }
        else if (nestData[i].values[j].Level == "Non-Incap. Injury (B)"){
          intersectTotal+=3;
        }
        else if (nestData[i].values[j].Level == "Incap. Injury (A)"){
          intersectTotal+=4;
        }
      }
      nestData[i].intersectTotal = intersectTotal
    }

    var sortedNestData = nestData.sort(function(a,b){
      return b.intersectTotal - a.intersectTotal;
    });

    console.log(sortedNestData);

    def.resolve();
  });

  return def.promise;
}




    </script>
  </body>
</html>
